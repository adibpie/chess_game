<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess Game - Retro Edition</title>
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        @keyframes pixelate {
            0%, 100% { image-rendering: pixelated; }
        }
        
        body {
            font-family: 'Courier New', monospace;
            background: #141428;
            background-image: 
                linear-gradient(rgba(30, 30, 50, 0.5) 1px, transparent 1px),
                linear-gradient(90deg, rgba(30, 30, 50, 0.5) 1px, transparent 1px);
            background-size: 20px 20px;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }
        
        .container {
            background: #141428;
            border: 5px solid #ffff00;
            padding: 30px;
            max-width: 1200px;
            width: 100%;
            box-shadow: 0 0 20px rgba(255, 255, 0, 0.3);
        }
        
        h1 {
            text-align: center;
            color: #ffff00;
            margin-bottom: 10px;
            font-size: 48px;
            text-shadow: 3px 3px 0px #000, -1px -1px 0px #fff;
            letter-spacing: 3px;
            image-rendering: pixelated;
        }
        
        .subtitle {
            text-align: center;
            color: #c8c8c8;
            margin-bottom: 30px;
            font-size: 24px;
            letter-spacing: 2px;
        }
        
        .menu-screen {
            text-align: center;
        }
        
        .menu-button {
            display: block;
            width: 100%;
            max-width: 500px;
            margin: 20px auto;
            padding: 20px 30px;
            font-size: 24px;
            font-weight: bold;
            font-family: 'Courier New', monospace;
            color: #000;
            border: none;
            cursor: pointer;
            letter-spacing: 2px;
            position: relative;
            image-rendering: pixelated;
            transition: transform 0.1s;
        }
        
        .menu-button:active {
            transform: translate(2px, 2px);
        }
        
        .menu-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border: 3px solid #000;
            border-top-color: #fff;
            border-left-color: #fff;
            border-bottom-color: #666;
            border-right-color: #666;
        }
        
        .menu-button:hover::before {
            border-top-color: #fff;
            border-left-color: #fff;
            border-bottom-color: #888;
            border-right-color: #888;
        }
        
        .btn-pvp {
            background: #6495ed;
        }
        
        .btn-ai {
            background: #90ee90;
        }
        
        .btn-online {
            background: #ffd700;
        }
        
        .btn-back {
            background: #c0c0c0;
        }
        
        .room-input {
            width: 100%;
            max-width: 400px;
            padding: 15px;
            margin: 20px auto;
            display: block;
            font-size: 20px;
            font-family: 'Courier New', monospace;
            background: #000;
            color: #ffff00;
            border: 3px solid #ffff00;
            text-align: center;
            letter-spacing: 3px;
            text-transform: uppercase;
        }
        
        .room-input:focus {
            outline: none;
            border-color: #fff;
        }
        
        .game-board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 0;
            width: 640px;
            height: 640px;
            margin: 20px auto;
            border: 5px solid #ffff00;
            image-rendering: pixelated;
        }
        
        .square {
            width: 80px;
            height: 80px;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            cursor: pointer;
        }
        
        .square.light {
            background: #f0d9b5;
        }
        
        .square.dark {
            background: #b58863;
        }
        
        .square.selected {
            background: #ff6b6b !important;
            border: 3px solid #000;
        }
        
        .square.valid-move {
            background: #51cf66 !important;
        }
        
        .piece {
            font-size: 60px;
            cursor: pointer;
            user-select: none;
            image-rendering: pixelated;
            filter: drop-shadow(2px 2px 0px #000);
        }
        
        .game-info {
            text-align: center;
            margin: 20px 0;
            font-size: 20px;
            color: #ffff00;
            font-family: 'Courier New', monospace;
        }
        
        .status-message {
            padding: 15px;
            margin: 15px 0;
            border: 3px solid #ffff00;
            background: #000;
            color: #ffff00;
            font-family: 'Courier New', monospace;
            font-size: 18px;
            letter-spacing: 1px;
        }
        
        .hidden {
            display: none;
        }
        
        .room-code-display {
            background: #000;
            padding: 20px;
            border: 3px solid #ffff00;
            margin: 20px 0;
            text-align: center;
        }
        
        .room-code-display code {
            font-size: 32px;
            font-weight: bold;
            color: #ffff00;
            font-family: 'Courier New', monospace;
            letter-spacing: 5px;
        }
        
        .difficulty-selector {
            margin: 20px 0;
            color: #ffff00;
            font-family: 'Courier New', monospace;
        }
        
        .difficulty-selector button {
            background: #000;
            color: #ffff00;
            border: 3px solid #ffff00;
            padding: 10px 20px;
            font-size: 24px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            margin: 0 10px;
        }
        
        .difficulty-selector button:hover {
            background: #ffff00;
            color: #000;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>♟️ CHESS GAME</h1>
        <div class="subtitle">RETRO EDITION</div>
        
        <!-- Main Menu Screen -->
        <div id="menuScreen" class="menu-screen">
            <button class="menu-button btn-pvp" onclick="startLocalPvP()">LOCAL PVP</button>
            <button class="menu-button btn-ai" onclick="showAISelection()">PLAY VS AI</button>
            <button class="menu-button btn-online" onclick="showOnlineMenu()">ONLINE MULTIPLAYER</button>
        </div>
        
        <!-- AI Selection Screen -->
        <div id="aiScreen" class="menu-screen hidden">
            <button class="menu-button btn-pvp" onclick="startAI('minimax')">MINIMAX AI</button>
            <button class="menu-button btn-ai" onclick="startAI('stockfish')">STOCKFISH AI</button>
            <div id="difficultySelector" class="difficulty-selector hidden">
                <button onclick="changeDifficulty(-1)">◄</button>
                <span id="difficultyText">DIFFICULTY (DEPTH): 3</span>
                <button onclick="changeDifficulty(1)">►</button>
            </div>
            <button class="menu-button btn-back" onclick="showMainMenu()">BACK</button>
        </div>
        
        <!-- Online Menu Screen -->
        <div id="onlineScreen" class="menu-screen hidden">
            <button class="menu-button btn-pvp" onclick="createRoom()">CREATE ROOM</button>
            <button class="menu-button btn-ai" onclick="showJoinRoom()">JOIN ROOM</button>
            <div id="joinRoomDiv" class="hidden">
                <input type="text" id="roomCodeInput" class="room-input" placeholder="ENTER ROOM CODE" maxlength="6" onkeypress="if(event.key==='Enter') joinRoom()">
            </div>
            <button class="menu-button btn-back" onclick="showMainMenu()">BACK</button>
        </div>
        
        <!-- Game Screen -->
        <div id="gameScreen" class="hidden">
            <div class="room-code-display" id="roomCodeDisplay" style="display: none;">
                Room Code: <code id="roomCodeText"></code>
            </div>
            <div class="game-info">
                <div id="statusMessage" class="status-message">Waiting for opponent...</div>
                <div id="turnIndicator"></div>
            </div>
            <div id="gameBoard" class="game-board"></div>
        </div>
    </div>
    
    <script>
        // Server URL - use current origin for WebSocket connection
        const serverUrl = window.location.origin;
        const socket = io(serverUrl, {
            transports: ['websocket', 'polling']
        });
        let roomCode = null;
        let playerColor = null;
        let board = [];
        let selectedSquare = null;
        let validMoves = [];
        let gameState = {
            whitePieces: [],
            whiteLocations: [],
            blackPieces: [],
            blackLocations: [],
            turnStep: 0
        };
        let currentMode = null;
        let aiDifficulty = 3;
        
        const pieceSymbols = {
            'white': {
                'pawn': '♙', 'rook': '♖', 'knight': '♘',
                'bishop': '♗', 'queen': '♕', 'king': '♔'
            },
            'black': {
                'pawn': '♟', 'rook': '♜', 'knight': '♞',
                'bishop': '♝', 'queen': '♛', 'king': '♚'
            }
        };
        
        // Menu Navigation
        function showMainMenu() {
            document.getElementById('menuScreen').classList.remove('hidden');
            document.getElementById('aiScreen').classList.add('hidden');
            document.getElementById('onlineScreen').classList.add('hidden');
            document.getElementById('gameScreen').classList.add('hidden');
        }
        
        function showAISelection() {
            document.getElementById('menuScreen').classList.add('hidden');
            document.getElementById('aiScreen').classList.remove('hidden');
            document.getElementById('difficultySelector').classList.remove('hidden');
        }
        
        function showOnlineMenu() {
            document.getElementById('menuScreen').classList.add('hidden');
            document.getElementById('onlineScreen').classList.remove('hidden');
        }
        
        function showJoinRoom() {
            document.getElementById('joinRoomDiv').classList.remove('hidden');
        }
        
        function startLocalPvP() {
            currentMode = 'local';
            document.getElementById('menuScreen').classList.add('hidden');
            document.getElementById('gameScreen').classList.remove('hidden');
            initializeGameState();
            initBoard();
            updateBoardDisplay();
            updateStatus('Local PvP - White to move');
        }
        
        function startAI(type) {
            // For web version, we'll use a simple AI (minimax-like)
            // Full Stockfish would require server-side processing
            currentMode = 'ai';
            playerColor = 'white';
            document.getElementById('aiScreen').classList.add('hidden');
            document.getElementById('gameScreen').classList.remove('hidden');
            initializeGameState();
            initBoard();
            updateBoardDisplay();
            updateStatus('Playing vs AI - Your turn (White)');
        }
        
        function changeDifficulty(delta) {
            aiDifficulty = Math.max(1, Math.min(5, aiDifficulty + delta));
            document.getElementById('difficultyText').textContent = `DIFFICULTY (DEPTH): ${aiDifficulty}`;
        }
        
        function createRoom() {
            socket.emit('create_room');
        }
        
        function joinRoom() {
            const code = document.getElementById('roomCodeInput').value.toUpperCase();
            if (code.length === 6) {
                socket.emit('join_room', { room_code: code });
            } else {
                alert('Please enter a valid 6-character room code');
            }
        }
        
        // Board Functions
        function initBoard() {
            const boardDiv = document.getElementById('gameBoard');
            boardDiv.innerHTML = '';
            board = [];
            
            for (let row = 0; row < 8; row++) {
                board[row] = [];
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    square.className = `square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
                    square.dataset.row = row;
                    square.dataset.col = col;
                    square.onclick = () => handleSquareClick(row, col);
                    boardDiv.appendChild(square);
                    board[row][col] = square;
                }
            }
        }
        
        function handleSquareClick(row, col) {
            if (currentMode === 'online' && !playerColor) return;
            
            const isMyTurn = currentMode === 'local' || 
                            (currentMode === 'ai' && gameState.turnStep < 2) ||
                            (currentMode === 'online' && ((playerColor === 'white' && gameState.turnStep < 2) || 
                                                          (playerColor === 'black' && gameState.turnStep >= 2)));
            
            if (!isMyTurn && currentMode !== 'local') return;
            
            const piece = getPieceAt(row, col);
            const isMyPiece = piece && ((currentMode === 'local') || 
                                       (currentMode === 'ai' && piece.color === 'white') ||
                                       (currentMode === 'online' && piece.color === playerColor));
            
            if (selectedSquare && validMoves.some(m => m[0] === row && m[1] === col)) {
                const [fromRow, fromCol] = selectedSquare;
                makeMove(fromRow, fromCol, row, col);
                clearSelection();
            } else if (isMyPiece) {
                selectedSquare = [row, col];
                updateValidMoves(row, col);
                updateBoardDisplay();
            } else {
                clearSelection();
            }
        }
        
        function getPieceAt(row, col) {
            for (let i = 0; i < gameState.whiteLocations.length; i++) {
                const loc = gameState.whiteLocations[i];
                if (loc[0] === col && loc[1] === row) {
                    return { color: 'white', type: gameState.whitePieces[i] };
                }
            }
            for (let i = 0; i < gameState.blackLocations.length; i++) {
                const loc = gameState.blackLocations[i];
                if (loc[0] === col && loc[1] === row) {
                    return { color: 'black', type: gameState.blackPieces[i] };
                }
            }
            return null;
        }
        
        function updateValidMoves(row, col) {
            // Simplified - calculate valid moves based on piece type
            validMoves = [];
            const piece = getPieceAt(row, col);
            if (!piece) return;
            
            // Basic move calculation (simplified)
            // In a full implementation, this would check all rules
            const directions = {
                'pawn': piece.color === 'white' ? [[0, 1], [0, 2], [-1, 1], [1, 1]] : [[0, -1], [0, -2], [-1, -1], [1, -1]],
                'rook': [[0, 1], [0, -1], [1, 0], [-1, 0]],
                'knight': [[1, 2], [2, 1], [-1, 2], [2, -1], [1, -2], [-2, 1], [-1, -2], [-2, -1]],
                'bishop': [[1, 1], [1, -1], [-1, 1], [-1, -1]],
                'queen': [[0, 1], [0, -1], [1, 0], [-1, 0], [1, 1], [1, -1], [-1, 1], [-1, -1]],
                'king': [[0, 1], [0, -1], [1, 0], [-1, 0], [1, 1], [1, -1], [-1, 1], [-1, -1]]
            };
            
            const moves = directions[piece.type] || [];
            for (const [dx, dy] of moves) {
                const newRow = row + dy;
                const newCol = col + dx;
                if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
                    const targetPiece = getPieceAt(newRow, newCol);
                    if (!targetPiece || targetPiece.color !== piece.color) {
                        validMoves.push([newRow, newCol]);
                    }
                }
            }
        }
        
        function makeMove(fromRow, fromCol, toRow, toCol) {
            const fromPos = [fromCol, fromRow];
            const toPos = [toCol, toRow];
            
            // Update local game state
            updateLocalMove(fromPos, toPos);
            
            if (currentMode === 'online') {
                socket.emit('make_move', {
                    room_code: roomCode,
                    from_pos: fromPos,
                    to_pos: toPos
                });
            } else if (currentMode === 'ai' && gameState.turnStep >= 2) {
                // AI's turn - make a simple move (in full version, this would call server AI)
                setTimeout(() => {
                    makeAIMove();
                }, 2000);
            }
        }
        
        function updateLocalMove(fromPos, toPos) {
            // Find and move piece
            const [fromCol, fromRow] = fromPos;
            const [toCol, toRow] = toPos;
            
            // Check white pieces
            for (let i = 0; i < gameState.whiteLocations.length; i++) {
                const loc = gameState.whiteLocations[i];
                if (loc[0] === fromCol && loc[1] === fromRow) {
                    gameState.whiteLocations[i] = [toCol, toRow];
                    // Check for capture
                    for (let j = gameState.blackLocations.length - 1; j >= 0; j--) {
                        const blackLoc = gameState.blackLocations[j];
                        if (blackLoc[0] === toCol && blackLoc[1] === toRow) {
                            gameState.blackPieces.splice(j, 1);
                            gameState.blackLocations.splice(j, 1);
                        }
                    }
                    gameState.turnStep = 2;
                    updateBoardDisplay();
                    return;
                }
            }
            
            // Check black pieces
            for (let i = 0; i < gameState.blackLocations.length; i++) {
                const loc = gameState.blackLocations[i];
                if (loc[0] === fromCol && loc[1] === fromRow) {
                    gameState.blackLocations[i] = [toCol, toRow];
                    // Check for capture
                    for (let j = gameState.whiteLocations.length - 1; j >= 0; j--) {
                        const whiteLoc = gameState.whiteLocations[j];
                        if (whiteLoc[0] === toCol && whiteLoc[1] === toRow) {
                            gameState.whitePieces.splice(j, 1);
                            gameState.whiteLocations.splice(j, 1);
                        }
                    }
                    gameState.turnStep = 0;
                    updateBoardDisplay();
                    return;
                }
            }
        }
        
        function makeAIMove() {
            // Simple AI move (random valid move)
            // In full version, this would use minimax or call server
            const moves = [];
            for (let i = 0; i < gameState.blackLocations.length; i++) {
                const loc = gameState.blackLocations[i];
                // Simple move: move pawn forward if possible
                if (gameState.blackPieces[i] === 'pawn' && loc[1] > 0) {
                    const newLoc = [loc[0], loc[1] - 1];
                    if (!getPieceAt(newLoc[1], newLoc[0])) {
                        moves.push([loc, newLoc]);
                    }
                }
            }
            if (moves.length > 0) {
                const move = moves[Math.floor(Math.random() * moves.length)];
                updateLocalMove(move[0], move[1]);
                updateStatus('AI is thinking...');
            }
        }
        
        function clearSelection() {
            selectedSquare = null;
            validMoves = [];
            updateBoardDisplay();
        }
        
        function updateBoardDisplay() {
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = board[row][col];
                    square.innerHTML = '';
                    square.classList.remove('selected', 'valid-move');
                    square.className = `square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
                }
            }
            
            drawPieces('white');
            drawPieces('black');
            
            if (selectedSquare) {
                const [row, col] = selectedSquare;
                board[row][col].classList.add('selected');
                validMoves.forEach(([r, c]) => {
                    board[r][c].classList.add('valid-move');
                });
            }
        }
        
        function drawPieces(color) {
            const pieces = color === 'white' ? gameState.whitePieces : gameState.blackPieces;
            const locations = color === 'white' ? gameState.whiteLocations : gameState.blackLocations;
            
            for (let i = 0; i < pieces.length; i++) {
                const piece = pieces[i];
                const loc = locations[i];
                const row = loc[1];
                const col = loc[0];
                
                const square = board[row][col];
                const symbol = pieceSymbols[color][piece];
                square.innerHTML = `<span class="piece">${symbol}</span>`;
            }
        }
        
        function initializeGameState() {
            gameState = {
                whitePieces: ['rook', 'knight', 'bishop', 'king', 'queen', 'bishop', 'knight', 'rook',
                             'pawn', 'pawn', 'pawn', 'pawn', 'pawn', 'pawn', 'pawn', 'pawn'],
                whiteLocations: [[0,0], [1,0], [2,0], [3,0], [4,0], [5,0], [6,0], [7,0],
                               [0,1], [1,1], [2,1], [3,1], [4,1], [5,1], [6,1], [7,1]],
                blackPieces: ['rook', 'knight', 'bishop', 'king', 'queen', 'bishop', 'knight', 'rook',
                             'pawn', 'pawn', 'pawn', 'pawn', 'pawn', 'pawn', 'pawn', 'pawn'],
                blackLocations: [[0,7], [1,7], [2,7], [3,7], [4,7], [5,7], [6,7], [7,7],
                               [0,6], [1,6], [2,6], [3,6], [4,6], [5,6], [6,6], [7,6]],
                turnStep: 0
            };
        }
        
        function updateStatus(message) {
            document.getElementById('statusMessage').textContent = message;
        }
        
        // Socket event handlers
        socket.on('connect', () => {
            console.log('Connected to server');
        });
        
        socket.on('room_created', (data) => {
            roomCode = data.room_code;
            playerColor = data.color;
            currentMode = 'online';
            document.getElementById('roomCodeText').textContent = roomCode;
            document.getElementById('roomCodeDisplay').style.display = 'block';
            document.getElementById('onlineScreen').classList.add('hidden');
            document.getElementById('gameScreen').classList.remove('hidden');
            updateStatus('Waiting for opponent...');
            initializeGameState();
            initBoard();
        });
        
        socket.on('joined_room', (data) => {
            roomCode = data.room_code;
            playerColor = data.color;
            currentMode = 'online';
            document.getElementById('roomCodeText').textContent = roomCode;
            document.getElementById('roomCodeDisplay').style.display = 'block';
            document.getElementById('onlineScreen').classList.add('hidden');
            document.getElementById('gameScreen').classList.remove('hidden');
            if (data.status === 'ready') {
                updateStatus('Game starting!');
            } else {
                updateStatus('Waiting for opponent...');
            }
            initializeGameState();
            initBoard();
        });
        
        socket.on('game_start', () => {
            updateStatus('Game started!');
            initializeGameState();
            updateBoardDisplay();
        });
        
        socket.on('opponent_move', (data) => {
            updateLocalMove(data.from_pos, data.to_pos);
            updateStatus('Opponent moved');
        });
        
        socket.on('game_state_update', (data) => {
            gameState = data.game_state;
            updateBoardDisplay();
        });
    </script>
</body>
</html>
