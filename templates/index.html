<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess Game - Online</title>
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Courier New', monospace;
        }
        
        body {
            font-family: 'Courier New', monospace;
            background: darkgray;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }
        
        .game-container {
            display: flex;
            gap: 0;
            background: darkgray;
            width: 1000px;
            height: 900px;
            max-width: 100%;
        }
        
        .board-container {
            position: relative;
            width: 800px;
            height: 900px;
            flex-shrink: 0;
            max-width: 100%;
        }
        
        .game-board {
            display: grid;
            grid-template-columns: repeat(8, 100px);
            grid-template-rows: repeat(8, 100px);
            width: 800px;
            height: 800px;
            border: 2px solid black;
            background: #f0d9b5;
            max-width: 100%;
        }
        
        .square {
            width: 100px;
            height: 100px;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            cursor: pointer;
            border: 1px solid black;
        }
        
        .square.light {
            background: #f0d9b5;
        }
        
        .square.dark {
            background: #b58863;
        }
        
        .square.selected {
            background: red !important;
            border: 2px solid darkred;
        }
        
        .square.valid-move::after {
            content: '';
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: red;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
        }
        
        .square.valid-move.blue-move::after {
            background: blue;
        }
        
        .piece-img {
            width: 80px;
            height: 80px;
            object-fit: contain;
            cursor: pointer;
            user-select: none;
            z-index: 5;
            position: relative;
        }
        
        .piece-img.pawn {
            width: 65px;
            height: 65px;
        }
        
        .sidebar {
            width: 200px;
            height: 900px;
            background: gold;
            border: 5px solid gold;
            display: flex;
            flex-direction: column;
            padding: 10px;
            flex-shrink: 0;
            overflow-y: auto;
        }
        
        .captured-section {
            margin-bottom: 20px;
        }
        
        .captured-title {
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .captured-pieces {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .captured-piece-img {
            width: 45px;
            height: 45px;
            object-fit: contain;
        }
        
        .status-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 800px;
            height: 100px;
            background: gray;
            border: 5px solid gold;
            display: flex;
            align-items: center;
            padding: 0 20px;
            font-size: 40px;
            color: black;
            font-weight: bold;
            z-index: 100;
            max-width: 100%;
        }
        
        .turn-indicator {
            font-size: 50px;
            font-weight: bold;
            margin-right: 20px;
            padding: 5px 15px;
            border: 3px solid black;
            background: white;
        }
        
        .turn-indicator.white-turn {
            background: white;
            color: black;
        }
        
        .turn-indicator.black-turn {
            background: black;
            color: white;
        }
        
        .forfeit-button {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 30px;
            cursor: pointer;
            color: black;
            background: lightcoral;
            padding: 5px 15px;
            border: 2px solid darkred;
            border-radius: 5px;
            font-weight: bold;
            user-select: none;
        }
        
        .forfeit-button:hover {
            background: red;
            color: white;
        }
        
        .forfeit-button:active {
            background: darkred;
        }
        
        .menu-screen {
            text-align: center;
            background: darkgray;
            padding: 50px;
            width: 100%;
            max-width: 600px;
        }
        
        .menu-button {
            display: block;
            width: 100%;
            max-width: 500px;
            margin: 20px auto;
            padding: 20px 30px;
            font-size: 24px;
            background: lightblue;
            color: black;
            border: 3px solid black;
            cursor: pointer;
            font-weight: bold;
        }
        
        .menu-button:hover {
            background: lightcyan;
        }
        
        .room-input {
            width: 100%;
            max-width: 400px;
            padding: 15px;
            margin: 20px auto;
            display: block;
            font-size: 20px;
            border: 3px solid black;
            text-align: center;
            text-transform: uppercase;
        }
        
        .hidden {
            display: none !important;
        }
        
        .room-code-display {
            text-align: center;
            margin: 20px 0;
            font-size: 24px;
            font-weight: bold;
        }
        
        /* Promotion overlay */
        .promotion-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            pointer-events: none;
        }
        
        .promotion-overlay:not(.hidden) {
            display: flex;
            pointer-events: auto;
        }
        
        .promotion-menu {
            background: gray;
            border: 5px solid gold;
            padding: 20px;
            display: flex;
            gap: 10px;
            border-radius: 10px;
        }
        
        .promotion-piece {
            width: 80px;
            height: 80px;
            cursor: pointer;
            border: 3px solid black;
            background: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 60px;
        }
        
        .promotion-piece:hover {
            background: lightblue;
            border-color: blue;
        }
        
        /* Check indicator */
        .square.in-check {
            border: 5px solid darkred !important;
            animation: checkFlash 0.5s infinite;
        }
        
        .square.in-check.black-king {
            border-color: darkblue !important;
        }
        
        @keyframes checkFlash {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        /* Game Over Modal */
        .game-over-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            pointer-events: auto;
        }
        
        .game-over-modal:not(.hidden) {
            display: flex;
        }
        
        .game-over-content {
            background: black;
            border: 5px solid gold;
            padding: 40px;
            text-align: center;
            border-radius: 10px;
            color: white;
            max-width: 500px;
            width: 90%;
        }
        
        .game-over-title {
            font-size: 48px;
            font-weight: bold;
            margin-bottom: 20px;
            color: gold;
        }
        
        .game-over-message {
            font-size: 32px;
            margin-bottom: 30px;
        }
        
        .game-over-button {
            background: lightblue;
            color: black;
            border: 3px solid black;
            padding: 15px 30px;
            font-size: 24px;
            cursor: pointer;
            font-weight: bold;
            border-radius: 5px;
        }
        
        .game-over-button:hover {
            background: lightcyan;
        }
        
        /* Mobile Responsive */
        @media (max-width: 1024px) {
            .game-container {
                flex-direction: column;
                width: 100%;
                height: auto;
                max-width: 100vw;
            }
            
            .board-container {
                width: 100%;
                height: auto;
                max-width: 100vw;
            }
            
            .game-board {
                width: 100%;
                max-width: 100vw;
                grid-template-columns: repeat(8, 12.5vw);
                grid-template-rows: repeat(8, 12.5vw);
            }
            
            .square {
                width: 12.5vw;
                height: 12.5vw;
            }
            
            .piece-img {
                width: 10vw;
                height: 10vw;
            }
            
            .piece-img.pawn {
                width: 8vw;
                height: 8vw;
            }
            
            .status-bar {
                width: 100%;
                max-width: 100vw;
                height: 80px;
                font-size: 20px;
                padding: 0 10px;
            }
            
            .turn-indicator {
                font-size: 24px;
                padding: 3px 10px;
                margin-right: 10px;
            }
            
            .forfeit-button {
                font-size: 16px;
                padding: 3px 10px;
                right: 5px;
            }
            
            .sidebar {
                width: 100%;
                height: auto;
                max-height: 200px;
                flex-direction: row;
                justify-content: space-around;
                padding: 10px;
            }
            
            .captured-section {
                margin-bottom: 0;
                margin-right: 10px;
            }
            
            .captured-pieces {
                flex-direction: row;
                flex-wrap: wrap;
            }
            
            .menu-screen {
                padding: 20px;
            }
            
            .menu-button {
                font-size: 18px;
                padding: 15px 20px;
            }
        }
        
        @media (max-width: 600px) {
            .game-board {
                grid-template-columns: repeat(8, 12.5vw);
                grid-template-rows: repeat(8, 12.5vw);
            }
            
            .status-bar {
                font-size: 16px;
                height: 60px;
            }
            
            .turn-indicator {
                font-size: 18px;
                padding: 2px 8px;
            }
            
            .forfeit-button {
                font-size: 14px;
                padding: 2px 8px;
            }
            
            .promotion-menu {
                flex-wrap: wrap;
                max-width: 90vw;
            }
            
            .promotion-piece {
                width: 60px;
                height: 60px;
                font-size: 40px;
            }
        }
    </style>
</head>
<body>
    <!-- Menu Screen -->
    <div id="menuScreen" class="menu-screen">
        <h1 style="font-size: 50px; margin-bottom: 30px;">CHESS GAME</h1>
        <button class="menu-button" onclick="startLocalPvP()">LOCAL PVP</button>
        <button class="menu-button" onclick="showOnlineMenu()">ONLINE MULTIPLAYER</button>
        <div id="onlineMenu" class="hidden">
            <button class="menu-button" onclick="createRoom()">CREATE ROOM</button>
            <button class="menu-button" onclick="showJoinRoom()">JOIN ROOM</button>
            <div id="joinRoomDiv" class="hidden">
                <input type="text" id="roomCodeInput" class="room-input" placeholder="ENTER ROOM CODE" maxlength="6" onkeypress="if(event.key==='Enter') joinRoom()">
            </div>
        </div>
    </div>
    
    <!-- Game Screen -->
    <div id="gameScreen" class="hidden">
        <div class="room-code-display" id="roomCodeDisplay" style="display: none;">
            Room Code: <code id="roomCodeText" style="font-size: 32px; letter-spacing: 5px;"></code>
        </div>
        <div class="game-container">
            <div class="board-container">
                <div id="gameBoard" class="game-board"></div>
                <div class="status-bar">
                    <span id="turnIndicator" class="turn-indicator white-turn">WHITE</span>
                    <span id="statusMessage">Select a Piece to Move!</span>
                    <span class="forfeit-button" onclick="forfeit()">FORFEIT</span>
                </div>
            </div>
            <div class="sidebar">
                <div class="captured-section">
                    <div class="captured-title">Captured (White)</div>
                    <div id="capturedWhite" class="captured-pieces"></div>
                </div>
                <div class="captured-section">
                    <div class="captured-title">Captured (Black)</div>
                    <div id="capturedBlack" class="captured-pieces"></div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Promotion Overlay -->
    <div id="promotionOverlay" class="promotion-overlay hidden">
        <div class="promotion-menu" id="promotionMenu"></div>
    </div>
    
    <!-- Game Over Modal -->
    <div id="gameOverModal" class="game-over-modal hidden">
        <div class="game-over-content">
            <div class="game-over-title">GAME OVER</div>
            <div class="game-over-message" id="gameOverMessage"></div>
            <button class="game-over-button" onclick="restartGame()">NEW GAME</button>
        </div>
    </div>
    
    <script>
        const socket = io(window.location.origin, {
            transports: ['websocket', 'polling']
        });
        
        let roomCode = null;
        let playerColor = null;
        let board = [];
        let selectedSquare = null;
        let validMoves = [];
        let pendingPromotion = null; // {pieceIndex, color, location}
        let checkFlashCounter = 0; // Counter for flashing check indicator
        let gameState = {
            whitePieces: [],
            whiteLocations: [],
            blackPieces: [],
            blackLocations: [],
            whiteMoved: [],
            blackMoved: [],
            capturedPiecesWhite: [],
            capturedPiecesBlack: [],
            turnStep: 0,
            gameOver: false,
            winner: '',
            whiteEp: [100, 100],
            blackEp: [100, 100],
            inCheck: false,
            checkedKing: null // {color: 'white' or 'black', location: [col, row]}
        };
        let currentMode = null;
        
        // Piece image mapping
        const pieceImages = {
            'white': {
                'pawn': '/assets/images/white pawn.png',
                'rook': '/assets/images/white rook.png',
                'knight': '/assets/images/white knight.png',
                'bishop': '/assets/images/white bishop.png',
                'queen': '/assets/images/white queen.png',
                'king': '/assets/images/white king.png'
            },
            'black': {
                'pawn': '/assets/images/black pawn.png',
                'rook': '/assets/images/black rook.png',
                'knight': '/assets/images/black knight.png',
                'bishop': '/assets/images/black bishop.png',
                'queen': '/assets/images/black queen.png',
                'king': '/assets/images/black king.png'
            }
        };
        
        const smallPieceImages = {
            'white': {
                'pawn': '/assets/images/white pawn.png',
                'rook': '/assets/images/white rook.png',
                'knight': '/assets/images/white knight.png',
                'bishop': '/assets/images/white bishop.png',
                'queen': '/assets/images/white queen.png',
                'king': '/assets/images/white king.png'
            },
            'black': {
                'pawn': '/assets/images/black pawn.png',
                'rook': '/assets/images/black rook.png',
                'knight': '/assets/images/black knight.png',
                'bishop': '/assets/images/black bishop.png',
                'queen': '/assets/images/black queen.png',
                'king': '/assets/images/black king.png'
            }
        };
        
        const promotionPieces = ['queen', 'rook', 'bishop', 'knight'];
        const promotionSymbols = {
            'white': {'queen': '♕', 'rook': '♖', 'bishop': '♗', 'knight': '♘'},
            'black': {'queen': '♛', 'rook': '♜', 'bishop': '♝', 'knight': '♞'}
        };
        
        // Menu Functions
        function startLocalPvP() {
            currentMode = 'local';
            document.getElementById('menuScreen').classList.add('hidden');
            document.getElementById('gameScreen').classList.remove('hidden');
            initializeGameState();
            initBoard();
            updateBoardDisplay();
            updateStatus();
        }
        
        function showOnlineMenu() {
            document.getElementById('onlineMenu').classList.remove('hidden');
        }
        
        function showJoinRoom() {
            document.getElementById('joinRoomDiv').classList.remove('hidden');
        }
        
        function createRoom() {
            socket.emit('create_room');
        }
        
        function joinRoom() {
            const code = document.getElementById('roomCodeInput').value.toUpperCase();
            if (code.length === 6) {
                socket.emit('join_room', { room_code: code });
            }
        }
        
        function forfeit() {
            if (confirm('Are you sure you want to forfeit?')) {
                if (currentMode === 'online' && roomCode) {
                    socket.emit('forfeit', { room_code: roomCode });
                    const forfeitingColor = (playerColor === 'white' && gameState.turnStep < 2) || 
                                          (playerColor === 'black' && gameState.turnStep >= 2);
                    gameState.winner = forfeitingColor ? (playerColor === 'white' ? 'black' : 'white') : playerColor;
                    gameState.gameOver = true;
                    updateBoardDisplay();
                    updateStatus();
                } else {
                    if (gameState.turnStep < 2) {
                        gameState.winner = 'black';
                    } else {
                        gameState.winner = 'white';
                    }
                    gameState.gameOver = true;
                    updateBoardDisplay();
                    updateStatus();
                }
            }
        }
        
        function goBackToMenu() {
            if (currentMode === 'online' && roomCode) {
                if (confirm('Leave the game and return to menu?')) {
                    socket.emit('forfeit', { room_code: roomCode });
                    socket.disconnect();
                } else {
                    return;
                }
            }
            currentMode = null;
            roomCode = null;
            playerColor = null;
            selectedSquare = null;
            validMoves = [];
            gameState = {};
            pendingPromotion = null;
            
            const promotionOverlay = document.getElementById('promotionOverlay');
            if (promotionOverlay) {
                promotionOverlay.classList.add('hidden');
            }
            
            document.getElementById('gameScreen').classList.add('hidden');
            document.getElementById('menuScreen').classList.remove('hidden');
            document.getElementById('onlineMenu').classList.add('hidden');
            document.getElementById('joinRoomDiv').classList.add('hidden');
            document.getElementById('roomCodeDisplay').style.display = 'none';
            document.getElementById('roomCodeInput').value = '';
        }
        
        // Board Functions
        function initBoard() {
            const boardDiv = document.getElementById('gameBoard');
            boardDiv.innerHTML = '';
            board = [];
            
            for (let row = 0; row < 8; row++) {
                board[row] = [];
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    const isLight = (row + col) % 2 === 0;
                    square.className = `square ${isLight ? 'light' : 'dark'}`;
                    square.dataset.row = row;
                    square.dataset.col = col;
                    square.onclick = () => handleSquareClick(row, col);
                    boardDiv.appendChild(square);
                    board[row][col] = square;
                }
            }
        }
        
        function handleSquareClick(row, col) {
            if (gameState.gameOver || pendingPromotion) return;
            
            const isWhiteTurn = gameState.turnStep < 2;
            const isMyTurn = currentMode === 'local' || 
                            (currentMode === 'online' && ((playerColor === 'white' && isWhiteTurn) || 
                                                          (playerColor === 'black' && !isWhiteTurn)));
            
            if (!isMyTurn && currentMode === 'online') {
                alert('Not your turn!');
                return;
            }
            
            const piece = getPieceAt(row, col);
            
            // If a piece is already selected and this is a valid move, execute the move
            if (selectedSquare && validMoves.some(m => m[0] === row && m[1] === col)) {
                const [fromRow, fromCol] = selectedSquare;
                makeMove(fromRow, fromCol, row, col);
                clearSelection();
                return;
            }
            
            // If clicking on a piece, check if it's the correct turn
            if (piece) {
                const pieceIsWhite = piece.color === 'white';
                
                // In local mode, check if piece matches current turn
                if (currentMode === 'local') {
                    if (pieceIsWhite !== isWhiteTurn) {
                        // Don't show alert if clicking on opponent piece when trying to capture
                        // Just clear selection
                        clearSelection();
                        return;
                    }
                } else {
                    // In online mode, check if piece belongs to player
                    const isMyPiece = (playerColor === 'white' && piece.color === 'white') ||
                                     (playerColor === 'black' && piece.color === 'black');
                    if (!isMyPiece) {
                        clearSelection();
                        return;
                    }
                }
                
                // Select this piece
                selectedSquare = [row, col];
                updateValidMoves(row, col);
                updateBoardDisplay();
            } else {
                // Clicked on empty square, clear selection
                clearSelection();
            }
        }
        
        function getPieceAt(row, col) {
            for (let i = 0; i < gameState.whiteLocations.length; i++) {
                const loc = gameState.whiteLocations[i];
                if (loc[0] === col && loc[1] === row) {
                    return { color: 'white', type: gameState.whitePieces[i], index: i };
                }
            }
            for (let i = 0; i < gameState.blackLocations.length; i++) {
                const loc = gameState.blackLocations[i];
                if (loc[0] === col && loc[1] === row) {
                    return { color: 'black', type: gameState.blackPieces[i], index: i };
                }
            }
            return null;
        }

        function cloneLocations(locations) {
            return locations.map(loc => [loc[0], loc[1]]);
        }

        function getPieceAtState(state, row, col) {
            for (let i = 0; i < state.whiteLocations.length; i++) {
                const loc = state.whiteLocations[i];
                if (loc[0] === col && loc[1] === row) {
                    return { color: 'white', type: state.whitePieces[i], index: i };
                }
            }
            for (let i = 0; i < state.blackLocations.length; i++) {
                const loc = state.blackLocations[i];
                if (loc[0] === col && loc[1] === row) {
                    return { color: 'black', type: state.blackPieces[i], index: i };
                }
            }
            return null;
        }

        function buildMovedArraysFromPositions(state, color) {
            const pieces = color === 'white' ? state.whitePieces : state.blackPieces;
            const locations = color === 'white' ? state.whiteLocations : state.blackLocations;
            const moved = pieces.map(() => false);
            const kingIndex = pieces.indexOf('king');
            const kingStart = color === 'white' ? [3, 0] : [3, 7];
            if (kingIndex !== -1) {
                const kingLoc = locations[kingIndex];
                if (kingLoc[0] !== kingStart[0] || kingLoc[1] !== kingStart[1]) {
                    moved[kingIndex] = true;
                }
            }
            for (let i = 0; i < pieces.length; i++) {
                if (pieces[i] !== 'rook') continue;
                const rookLoc = locations[i];
                const rookRow = color === 'white' ? 0 : 7;
                const isOnStart = (rookLoc[0] === 0 && rookLoc[1] === rookRow) ||
                                  (rookLoc[0] === 7 && rookLoc[1] === rookRow);
                if (!isOnStart) {
                    moved[i] = true;
                }
            }
            return moved;
        }

        function ensureMovedArrays() {
            if (!Array.isArray(gameState.whiteMoved) || gameState.whiteMoved.length !== gameState.whitePieces.length) {
                gameState.whiteMoved = buildMovedArraysFromPositions(gameState, 'white');
            }
            if (!Array.isArray(gameState.blackMoved) || gameState.blackMoved.length !== gameState.blackPieces.length) {
                gameState.blackMoved = buildMovedArraysFromPositions(gameState, 'black');
            }
        }

        function cloneGameState(state) {
            return {
                whitePieces: state.whitePieces.slice(),
                whiteLocations: cloneLocations(state.whiteLocations),
                blackPieces: state.blackPieces.slice(),
                blackLocations: cloneLocations(state.blackLocations),
                whiteMoved: Array.isArray(state.whiteMoved) ? state.whiteMoved.slice() : [],
                blackMoved: Array.isArray(state.blackMoved) ? state.blackMoved.slice() : [],
                whiteEp: state.whiteEp ? state.whiteEp.slice() : [100, 100],
                blackEp: state.blackEp ? state.blackEp.slice() : [100, 100]
            };
        }

        function getPseudoMovesForPiece(state, row, col, forAttack = false) {
            const moves = [];
            const piece = getPieceAtState(state, row, col);
            if (!piece) return moves;
            const direction = piece.color === 'white' ? 1 : -1;

            if (piece.type === 'pawn') {
                const nextRow = row + direction;
                if (forAttack) {
                    if (nextRow >= 0 && nextRow < 8) {
                        if (col + 1 < 8) moves.push([nextRow, col + 1]);
                        if (col - 1 >= 0) moves.push([nextRow, col - 1]);
                    }
                    return moves;
                }

                if (nextRow >= 0 && nextRow < 8 && !getPieceAtState(state, nextRow, col)) {
                    moves.push([nextRow, col]);
                    const startRow = piece.color === 'white' ? 1 : 6;
                    const twoRow = row + direction * 2;
                    if (row === startRow && !getPieceAtState(state, twoRow, col)) {
                        moves.push([twoRow, col]);
                    }
                }

                const diagRow = row + direction;
                if (diagRow >= 0 && diagRow < 8) {
                    const rightCol = col + 1;
                    const leftCol = col - 1;
                    if (rightCol < 8) {
                        const target = getPieceAtState(state, diagRow, rightCol);
                        if (target && target.color !== piece.color) {
                            moves.push([diagRow, rightCol]);
                        }
                        const ep = piece.color === 'white' ? state.blackEp : state.whiteEp;
                        if (ep && ep[0] === rightCol && ep[1] === diagRow) {
                            moves.push([diagRow, rightCol]);
                        }
                    }
                    if (leftCol >= 0) {
                        const target = getPieceAtState(state, diagRow, leftCol);
                        if (target && target.color !== piece.color) {
                            moves.push([diagRow, leftCol]);
                        }
                        const ep = piece.color === 'white' ? state.blackEp : state.whiteEp;
                        if (ep && ep[0] === leftCol && ep[1] === diagRow) {
                            moves.push([diagRow, leftCol]);
                        }
                    }
                }

                return moves;
            }

            const directions = {
                'rook': [[0, 1], [0, -1], [1, 0], [-1, 0]],
                'knight': [[1, 2], [2, 1], [-1, 2], [2, -1], [1, -2], [-2, 1], [-1, -2], [-2, -1]],
                'bishop': [[1, 1], [1, -1], [-1, 1], [-1, -1]],
                'queen': [[0, 1], [0, -1], [1, 0], [-1, 0], [1, 1], [1, -1], [-1, 1], [-1, -1]],
                'king': [[0, 1], [0, -1], [1, 0], [-1, 0], [1, 1], [1, -1], [-1, 1], [-1, -1]]
            };

            const movesList = directions[piece.type] || [];
            const isSliding = ['rook', 'bishop', 'queen'].includes(piece.type);

            for (const [dx, dy] of movesList) {
                if (isSliding) {
                    for (let dist = 1; dist < 8; dist++) {
                        const newRow = row + dy * dist;
                        const newCol = col + dx * dist;
                        if (newRow < 0 || newRow >= 8 || newCol < 0 || newCol >= 8) break;
                        const targetPiece = getPieceAtState(state, newRow, newCol);
                        if (!targetPiece) {
                            moves.push([newRow, newCol]);
                        } else {
                            if (targetPiece.color !== piece.color) {
                                moves.push([newRow, newCol]);
                            }
                            break;
                        }
                    }
                } else {
                    const newRow = row + dy;
                    const newCol = col + dx;
                    if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
                        const targetPiece = getPieceAtState(state, newRow, newCol);
                        if (!targetPiece || targetPiece.color !== piece.color) {
                            moves.push([newRow, newCol]);
                        }
                    }
                }
            }

            return moves;
        }

        function isSquareAttacked(state, row, col, byColor) {
            const pieces = byColor === 'white' ? state.whitePieces : state.blackPieces;
            const locations = byColor === 'white' ? state.whiteLocations : state.blackLocations;
            const direction = byColor === 'white' ? 1 : -1;

            for (let i = 0; i < pieces.length; i++) {
                const piece = pieces[i];
                const loc = locations[i];
                if (!loc || loc.length < 2) continue;
                const pRow = loc[1];
                const pCol = loc[0];

                if (piece === 'pawn') {
                    const attackRow = pRow + direction;
                    if (attackRow === row && (pCol + 1 === col || pCol - 1 === col)) {
                        return true;
                    }
                    continue;
                }

                if (piece === 'knight') {
                    const moves = [[1, 2], [2, 1], [-1, 2], [2, -1], [1, -2], [-2, 1], [-1, -2], [-2, -1]];
                    for (const [dx, dy] of moves) {
                        if (pRow + dy === row && pCol + dx === col) {
                            return true;
                        }
                    }
                    continue;
                }

                if (piece === 'king') {
                    const moves = [[0, 1], [0, -1], [1, 0], [-1, 0], [1, 1], [1, -1], [-1, 1], [-1, -1]];
                    for (const [dx, dy] of moves) {
                        if (pRow + dy === row && pCol + dx === col) {
                            return true;
                        }
                    }
                    continue;
                }

                const directions = {
                    'rook': [[0, 1], [0, -1], [1, 0], [-1, 0]],
                    'bishop': [[1, 1], [1, -1], [-1, 1], [-1, -1]],
                    'queen': [[0, 1], [0, -1], [1, 0], [-1, 0], [1, 1], [1, -1], [-1, 1], [-1, -1]]
                };
                const rays = directions[piece] || [];
                for (const [dx, dy] of rays) {
                    for (let dist = 1; dist < 8; dist++) {
                        const newRow = pRow + dy * dist;
                        const newCol = pCol + dx * dist;
                        if (newRow < 0 || newRow >= 8 || newCol < 0 || newCol >= 8) break;
                        if (newRow === row && newCol === col) {
                            const occupied = getPieceAtState(state, newRow, newCol);
                            if (!occupied || occupied.color !== byColor) {
                                return true;
                            }
                            break;
                        }
                        if (getPieceAtState(state, newRow, newCol)) {
                            break;
                        }
                    }
                }
            }
            return false;
        }

        function isKingInCheck(state, color) {
            const pieces = color === 'white' ? state.whitePieces : state.blackPieces;
            const locations = color === 'white' ? state.whiteLocations : state.blackLocations;
            const kingIndex = pieces.indexOf('king');
            if (kingIndex === -1) return false;
            const kingLoc = locations[kingIndex];
            const opponent = color === 'white' ? 'black' : 'white';
            return isSquareAttacked(state, kingLoc[1], kingLoc[0], opponent);
        }

        function applyMoveToState(state, fromRow, fromCol, toRow, toCol) {
            const piece = getPieceAtState(state, fromRow, fromCol);
            if (!piece) return;
            const isWhite = piece.color === 'white';
            const pieces = isWhite ? state.whitePieces : state.blackPieces;
            const locations = isWhite ? state.whiteLocations : state.blackLocations;
            const moved = isWhite ? state.whiteMoved : state.blackMoved;
            const oppPieces = isWhite ? state.blackPieces : state.whitePieces;
            const oppLocations = isWhite ? state.blackLocations : state.whiteLocations;
            const oppMoved = isWhite ? state.blackMoved : state.whiteMoved;

            let isEnPassant = false;
            if (piece.type === 'pawn') {
                const epTarget = isWhite ? state.blackEp : state.whiteEp;
                if (epTarget && epTarget[0] === toCol && epTarget[1] === toRow) {
                    isEnPassant = true;
                }
            }

            if (isEnPassant) {
                const pawnRow = isWhite ? toRow - 1 : toRow + 1;
                for (let j = oppLocations.length - 1; j >= 0; j--) {
                    const oppLoc = oppLocations[j];
                    if (oppLoc[0] === toCol && oppLoc[1] === pawnRow) {
                        oppPieces.splice(j, 1);
                        oppLocations.splice(j, 1);
                        if (Array.isArray(oppMoved)) {
                            oppMoved.splice(j, 1);
                        }
                        break;
                    }
                }
            } else {
                for (let j = oppLocations.length - 1; j >= 0; j--) {
                    const oppLoc = oppLocations[j];
                    if (oppLoc[0] === toCol && oppLoc[1] === toRow) {
                        oppPieces.splice(j, 1);
                        oppLocations.splice(j, 1);
                        if (Array.isArray(oppMoved)) {
                            oppMoved.splice(j, 1);
                        }
                        break;
                    }
                }
            }

            locations[piece.index] = [toCol, toRow];
            if (Array.isArray(moved) && moved.length > piece.index) {
                moved[piece.index] = true;
            }

            if (piece.type === 'king' && Math.abs(fromCol - toCol) === 2) {
                const rookFromCol = toCol > fromCol ? 7 : 0;
                const rookToCol = toCol > fromCol ? fromCol + 1 : fromCol - 1;
                const rookIndex = locations.findIndex(loc => loc[0] === rookFromCol && loc[1] === fromRow);
                if (rookIndex !== -1) {
                    locations[rookIndex] = [rookToCol, fromRow];
                    if (Array.isArray(moved) && moved.length > rookIndex) {
                        moved[rookIndex] = true;
                    }
                }
            }
        }

        function isMoveLegal(state, fromRow, fromCol, toRow, toCol, color) {
            const tempState = cloneGameState(state);
            applyMoveToState(tempState, fromRow, fromCol, toRow, toCol);
            return !isKingInCheck(tempState, color);
        }

        function getCastlingMoves(state, color) {
            const moves = [];
            const pieces = color === 'white' ? state.whitePieces : state.blackPieces;
            const locations = color === 'white' ? state.whiteLocations : state.blackLocations;
            const moved = color === 'white' ? state.whiteMoved : state.blackMoved;
            const kingIndex = pieces.indexOf('king');
            if (kingIndex === -1) return moves;
            if (Array.isArray(moved) && moved[kingIndex]) return moves;
            const kingLoc = locations[kingIndex];
            const kingRow = kingLoc[1];
            const kingCol = kingLoc[0];
            if (isKingInCheck(state, color)) return moves;
            const opponent = color === 'white' ? 'black' : 'white';

            for (let i = 0; i < pieces.length; i++) {
                if (pieces[i] !== 'rook') continue;
                if (Array.isArray(moved) && moved[i]) continue;
                const rookLoc = locations[i];
                if (rookLoc[1] !== kingRow) continue;
                if (rookLoc[0] !== 0 && rookLoc[0] !== 7) continue;
                const dir = rookLoc[0] > kingCol ? 1 : -1;
                let clear = true;
                for (let c = kingCol + dir; c !== rookLoc[0]; c += dir) {
                    if (getPieceAtState(state, kingRow, c)) {
                        clear = false;
                        break;
                    }
                }
                if (!clear) continue;

                const passSquares = [
                    [kingRow, kingCol + dir],
                    [kingRow, kingCol + dir * 2]
                ];
                let safe = true;
                for (const [r, c] of passSquares) {
                    if (isSquareAttacked(state, r, c, opponent)) {
                        safe = false;
                        break;
                    }
                }
                if (!safe) continue;
                moves.push([kingRow, kingCol + dir * 2]);
            }
            return moves;
        }

        function getLegalMovesForPiece(row, col) {
            const piece = getPieceAt(row, col);
            if (!piece) return [];
            ensureMovedArrays();
            const pseudoMoves = getPseudoMovesForPiece(gameState, row, col);
            const legalMoves = [];
            for (const [r, c] of pseudoMoves) {
                if (isMoveLegal(gameState, row, col, r, c, piece.color)) {
                    legalMoves.push([r, c]);
                }
            }
            if (piece.type === 'king') {
                const castles = getCastlingMoves(gameState, piece.color);
                for (const move of castles) {
                    if (isMoveLegal(gameState, row, col, move[0], move[1], piece.color)) {
                        legalMoves.push(move);
                    }
                }
            }
            return legalMoves;
        }
        
        function updateValidMoves(row, col) {
            validMoves = getLegalMovesForPiece(row, col);
        }
        
        function makeMove(fromRow, fromCol, toRow, toCol) {
            const fromPos = [fromCol, fromRow];
            const toPos = [toCol, toRow];
            
            // Check for en passant capture
            const isEnPassant = (gameState.turnStep < 2 && 
                                gameState.blackEp[0] === toCol && gameState.blackEp[1] === toRow) ||
                               (gameState.turnStep >= 2 && 
                                gameState.whiteEp[0] === toCol && gameState.whiteEp[1] === toRow);
            
            // Update local state
            updateLocalMove(fromPos, toPos, isEnPassant);
            
            if (currentMode === 'online' && roomCode) {
                socket.emit('make_move', {
                    room_code: roomCode,
                    from_pos: fromPos,
                    to_pos: toPos,
                    is_en_passant: isEnPassant,
                    game_state: gameState
                });
            }
        }
        
        function updateLocalMove(fromPos, toPos, isEnPassant = false) {
            const [fromCol, fromRow] = fromPos;
            const [toCol, toRow] = toPos;
            const isWhiteTurn = gameState.turnStep < 2;
            ensureMovedArrays();
            
            // Handle en passant capture
            if (isEnPassant) {
                if (isWhiteTurn) {
                    // White captures black pawn via en passant
                    const epPawnRow = toRow - 1;
                    for (let j = gameState.blackLocations.length - 1; j >= 0; j--) {
                        const blackLoc = gameState.blackLocations[j];
                        if (blackLoc[0] === toCol && blackLoc[1] === epPawnRow) {
                            gameState.capturedPiecesWhite.push(gameState.blackPieces[j]);
                            gameState.blackPieces.splice(j, 1);
                            gameState.blackLocations.splice(j, 1);
                            gameState.blackMoved.splice(j, 1);
                            break;
                        }
                    }
                } else {
                    // Black captures white pawn via en passant
                    const epPawnRow = toRow + 1;
                    for (let j = gameState.whiteLocations.length - 1; j >= 0; j--) {
                        const whiteLoc = gameState.whiteLocations[j];
                        if (whiteLoc[0] === toCol && whiteLoc[1] === epPawnRow) {
                            gameState.capturedPiecesBlack.push(gameState.whitePieces[j]);
                            gameState.whitePieces.splice(j, 1);
                            gameState.whiteLocations.splice(j, 1);
                            gameState.whiteMoved.splice(j, 1);
                            break;
                        }
                    }
                }
            }
            
            if (isWhiteTurn) {
                for (let i = 0; i < gameState.whiteLocations.length; i++) {
                    const loc = gameState.whiteLocations[i];
                    if (loc[0] === fromCol && loc[1] === fromRow) {
                        const pieceType = gameState.whitePieces[i];
                        const isCastling = pieceType === 'king' && Math.abs(fromCol - toCol) === 2;
                        gameState.whiteLocations[i] = [toCol, toRow];
                        gameState.whiteMoved[i] = true;
                        
                        // Check for normal capture (if not en passant)
                        if (!isEnPassant) {
                            for (let j = gameState.blackLocations.length - 1; j >= 0; j--) {
                                const blackLoc = gameState.blackLocations[j];
                                if (blackLoc[0] === toCol && blackLoc[1] === toRow) {
                                    gameState.capturedPiecesWhite.push(gameState.blackPieces[j]);
                                    if (gameState.blackPieces[j] === 'king') {
                                        gameState.winner = 'white';
                                        gameState.gameOver = true;
                                    }
                                    gameState.blackPieces.splice(j, 1);
                                    gameState.blackLocations.splice(j, 1);
                                    gameState.blackMoved.splice(j, 1);
                                    break;
                                }
                            }
                        }

                        if (isCastling) {
                            const rookFromCol = toCol > fromCol ? 7 : 0;
                            const rookToCol = toCol > fromCol ? fromCol + 1 : fromCol - 1;
                            const rookIndex = gameState.whiteLocations.findIndex(r => r[0] === rookFromCol && r[1] === fromRow);
                            if (rookIndex !== -1) {
                                gameState.whiteLocations[rookIndex] = [rookToCol, fromRow];
                                gameState.whiteMoved[rookIndex] = true;
                            }
                        }
                        
                        // Check for pawn promotion
                        if (pieceType === 'pawn' && toRow === 7) {
                            pendingPromotion = { pieceIndex: i, color: 'white', location: [toCol, toRow] };
                            showPromotionMenu('white');
                            return;
                        }
                        
                        // Update en passant target
                        if (pieceType === 'pawn' && Math.abs(fromRow - toRow) === 2) {
                            gameState.whiteEp = [toCol, toRow - 1];
                        } else {
                            gameState.whiteEp = [100, 100];
                        }
                        gameState.blackEp = [100, 100];
                        
                        gameState.turnStep = 2;
                        updateCapturedPieces();
                        updateBoardDisplay();
                        updateStatus();
                        return;
                    }
                }
            } else {
                for (let i = 0; i < gameState.blackLocations.length; i++) {
                    const loc = gameState.blackLocations[i];
                    if (loc[0] === fromCol && loc[1] === fromRow) {
                        const pieceType = gameState.blackPieces[i];
                        const isCastling = pieceType === 'king' && Math.abs(fromCol - toCol) === 2;
                        gameState.blackLocations[i] = [toCol, toRow];
                        gameState.blackMoved[i] = true;
                        
                        // Check for normal capture (if not en passant)
                        if (!isEnPassant) {
                            for (let j = gameState.whiteLocations.length - 1; j >= 0; j--) {
                                const whiteLoc = gameState.whiteLocations[j];
                                if (whiteLoc[0] === toCol && whiteLoc[1] === toRow) {
                                    gameState.capturedPiecesBlack.push(gameState.whitePieces[j]);
                                    if (gameState.whitePieces[j] === 'king') {
                                        gameState.winner = 'black';
                                        gameState.gameOver = true;
                                    }
                                    gameState.whitePieces.splice(j, 1);
                                    gameState.whiteLocations.splice(j, 1);
                                    gameState.whiteMoved.splice(j, 1);
                                    break;
                                }
                            }
                        }

                        if (isCastling) {
                            const rookFromCol = toCol > fromCol ? 7 : 0;
                            const rookToCol = toCol > fromCol ? fromCol + 1 : fromCol - 1;
                            const rookIndex = gameState.blackLocations.findIndex(r => r[0] === rookFromCol && r[1] === fromRow);
                            if (rookIndex !== -1) {
                                gameState.blackLocations[rookIndex] = [rookToCol, fromRow];
                                gameState.blackMoved[rookIndex] = true;
                            }
                        }
                        
                        // Check for pawn promotion
                        if (pieceType === 'pawn' && toRow === 0) {
                            pendingPromotion = { pieceIndex: i, color: 'black', location: [toCol, toRow] };
                            showPromotionMenu('black');
                            return;
                        }
                        
                        // Update en passant target
                        if (pieceType === 'pawn' && Math.abs(fromRow - toRow) === 2) {
                            gameState.blackEp = [toCol, toRow + 1];
                        } else {
                            gameState.blackEp = [100, 100];
                        }
                        gameState.whiteEp = [100, 100];
                        
                        gameState.turnStep = 0;
                        updateCapturedPieces();
                        updateBoardDisplay();
                        updateStatus();
                        return;
                    }
                }
            }
        }
        
        function showPromotionMenu(color) {
            const overlay = document.getElementById('promotionOverlay');
            const menu = document.getElementById('promotionMenu');
            menu.innerHTML = '';
            
            promotionPieces.forEach(pieceType => {
                const pieceDiv = document.createElement('div');
                pieceDiv.className = 'promotion-piece';
                pieceDiv.textContent = promotionSymbols[color][pieceType];
                pieceDiv.onclick = () => promotePawn(pieceType);
                menu.appendChild(pieceDiv);
            });
            
            overlay.classList.remove('hidden');
        }
        
        function promotePawn(pieceType) {
            if (!pendingPromotion) return;
            
            const overlay = document.getElementById('promotionOverlay');
            if (overlay) {
                overlay.classList.add('hidden');
            }
            
            const { pieceIndex, color } = pendingPromotion;
            
            if (color === 'white') {
                gameState.whitePieces[pieceIndex] = pieceType;
                // Advance turn after promotion (white -> black)
                gameState.turnStep = 2;
            } else {
                gameState.blackPieces[pieceIndex] = pieceType;
                // Advance turn after promotion (black -> white)
                gameState.turnStep = 0;
            }
            
            // Reset en passant targets
            gameState.whiteEp = [100, 100];
            gameState.blackEp = [100, 100];
            
            pendingPromotion = null;
            
            if (currentMode === 'online' && roomCode) {
                socket.emit('promote_pawn', {
                    room_code: roomCode,
                    piece_type: pieceType,
                    game_state: gameState
                });
            }
            
            updateBoardDisplay();
            updateCapturedPieces();
            updateStatus();
        }
        
        function checkForCheck() {
            gameState.inCheck = false;
            gameState.checkedKing = null;
            
            // Check if white king is in check
            const whiteKingIndex = gameState.whitePieces.indexOf('king');
            if (whiteKingIndex !== -1) {
                const whiteKingLoc = gameState.whiteLocations[whiteKingIndex];
                if (isSquareAttacked(gameState, whiteKingLoc[1], whiteKingLoc[0], 'black')) {
                    gameState.inCheck = true;
                    gameState.checkedKing = { color: 'white', location: whiteKingLoc };
                }
            }
            
            // Check if black king is in check
            const blackKingIndex = gameState.blackPieces.indexOf('king');
            if (blackKingIndex !== -1) {
                const blackKingLoc = gameState.blackLocations[blackKingIndex];
                if (isSquareAttacked(gameState, blackKingLoc[1], blackKingLoc[0], 'white')) {
                    gameState.inCheck = true;
                    gameState.checkedKing = { color: 'black', location: blackKingLoc };
                }
            }
        }
        
        function getAllValidMoves(color) {
            const allMoves = [];
            const pieces = color === 'white' ? gameState.whitePieces : gameState.blackPieces;
            const locations = color === 'white' ? gameState.whiteLocations : gameState.blackLocations;
            const tempSelected = selectedSquare;
            const tempValidMoves = validMoves.slice();
            
            for (let i = 0; i < pieces.length; i++) {
                const loc = locations[i];
                if (!loc || loc.length < 2) continue;
                const row = loc[1];
                const col = loc[0];
                
                // Temporarily set selectedSquare to get valid moves for this piece
                selectedSquare = [row, col];
                updateValidMoves(row, col);
                
                validMoves.forEach(move => {
                    allMoves.push([move[1], move[0]]); // Convert [row, col] to [col, row]
                });
            }
            
            selectedSquare = tempSelected;
            validMoves = tempValidMoves;
            
            return allMoves;
        }
        
        function checkForCheckmate() {
            if (!gameState.inCheck || !gameState.checkedKing) return false;
            
            const checkedColor = gameState.checkedKing.color;
            const pieces = checkedColor === 'white' ? gameState.whitePieces : gameState.blackPieces;
            const locations = checkedColor === 'white' ? gameState.whiteLocations : gameState.blackLocations;
            
            // Check if any piece can make a move
            for (let i = 0; i < pieces.length; i++) {
                const loc = locations[i];
                if (!loc || loc.length < 2) continue;
                const row = loc[1];
                const col = loc[0];
                
                const moves = getLegalMovesForPiece(row, col);
                if (moves.length > 0) {
                    return false; // Has moves available
                }
            }
            
            // No moves available = checkmate
            return true;
        }
        
        function showGameOver(winner) {
            gameState.gameOver = true;
            gameState.winner = winner;
            const modal = document.getElementById('gameOverModal');
            const message = document.getElementById('gameOverMessage');
            if (modal && message) {
                message.textContent = `${winner.toUpperCase()} WINS BY CHECKMATE!`;
                modal.classList.remove('hidden');
            }
            updateStatus();
        }
        
        function restartGame() {
            const modal = document.getElementById('gameOverModal');
            if (modal) {
                modal.classList.add('hidden');
            }
            initializeGameState();
            updateBoardDisplay();
            updateStatus();
        }
        
        function clearSelection() {
            selectedSquare = null;
            validMoves = [];
            updateBoardDisplay();
        }
        
        function updateBoardDisplay() {
            if (!board || board.length === 0) {
                initBoard();
            }
            
            // Increment check flash counter
            checkFlashCounter = (checkFlashCounter + 1) % 30;
            
            // Check for check and checkmate
            checkForCheck();
            if (gameState.inCheck && !gameState.gameOver) {
                const isCheckmate = checkForCheckmate();
                if (isCheckmate) {
                    const winner = gameState.checkedKing.color === 'white' ? 'black' : 'white';
                    showGameOver(winner);
                }
            }
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (!board[row] || !board[row][col]) continue;
                    const square = board[row][col];
                    square.innerHTML = '';
                    square.classList.remove('selected', 'valid-move', 'blue-move', 'in-check', 'black-king');
                    const isLight = (row + col) % 2 === 0;
                    square.className = `square ${isLight ? 'light' : 'dark'}`;
                }
            }
            
            drawPieces('white');
            drawPieces('black');
            
            // Draw check indicator (flashing)
            if (gameState.checkedKing && checkFlashCounter < 15 && !gameState.gameOver) {
                const kingLoc = gameState.checkedKing.location;
                const kingRow = kingLoc[1];
                const kingCol = kingLoc[0];
                if (board[kingRow] && board[kingRow][kingCol]) {
                    board[kingRow][kingCol].classList.add('in-check');
                    if (gameState.checkedKing.color === 'black') {
                        board[kingRow][kingCol].classList.add('black-king');
                    }
                }
            }
            
            if (selectedSquare) {
                const [row, col] = selectedSquare;
                if (board[row] && board[row][col]) {
                    const piece = getPieceAt(row, col);
                    const isWhite = piece && piece.color === 'white';
                    board[row][col].classList.add('selected');
                    validMoves.forEach(([r, c]) => {
                        if (board[r] && board[r][c]) {
                            board[r][c].classList.add('valid-move');
                            if (!isWhite) {
                                board[r][c].classList.add('blue-move');
                            }
                        }
                    });
                }
            }
        }
        
        function drawPieces(color) {
            const pieces = color === 'white' ? gameState.whitePieces : gameState.blackPieces;
            const locations = color === 'white' ? gameState.whiteLocations : gameState.blackLocations;
            
            for (let i = 0; i < pieces.length; i++) {
                const piece = pieces[i];
                const loc = locations[i];
                if (!loc || loc.length < 2) continue;
                const row = loc[1];
                const col = loc[0];
                
                if (!board[row] || !board[row][col]) continue;
                const square = board[row][col];
                const img = document.createElement('img');
                img.src = pieceImages[color][piece];
                img.alt = `${color} ${piece}`;
                img.className = `piece-img ${piece === 'pawn' ? 'pawn' : ''}`;
                img.onerror = function() {
                    const symbols = {
                        'white': {'pawn': '♙', 'rook': '♖', 'knight': '♘', 'bishop': '♗', 'queen': '♕', 'king': '♔'},
                        'black': {'pawn': '♟', 'rook': '♜', 'knight': '♞', 'bishop': '♝', 'queen': '♛', 'king': '♚'}
                    };
                    this.outerHTML = `<span style="font-size: 70px; line-height: 1;">${symbols[color][piece]}</span>`;
                };
                square.appendChild(img);
            }
        }
        
        function updateCapturedPieces() {
            const whiteDiv = document.getElementById('capturedWhite');
            const blackDiv = document.getElementById('capturedBlack');
            whiteDiv.innerHTML = '';
            blackDiv.innerHTML = '';
            
            gameState.capturedPiecesWhite.forEach(piece => {
                const img = document.createElement('img');
                img.src = smallPieceImages.black[piece];
                img.className = 'captured-piece-img';
                img.alt = `black ${piece}`;
                img.onerror = function() {
                    const symbols = {'pawn': '♟', 'rook': '♜', 'knight': '♞', 'bishop': '♝', 'queen': '♛', 'king': '♚'};
                    this.outerHTML = `<span style="font-size: 30px;">${symbols[piece] || '?'}</span>`;
                };
                whiteDiv.appendChild(img);
            });
            
            gameState.capturedPiecesBlack.forEach(piece => {
                const img = document.createElement('img');
                img.src = smallPieceImages.white[piece];
                img.className = 'captured-piece-img';
                img.alt = `white ${piece}`;
                img.onerror = function() {
                    const symbols = {'pawn': '♙', 'rook': '♖', 'knight': '♘', 'bishop': '♗', 'queen': '♕', 'king': '♔'};
                    this.outerHTML = `<span style="font-size: 30px;">${symbols[piece] || '?'}</span>`;
                };
                blackDiv.appendChild(img);
            });
        }
        
        function initializeGameState() {
            gameState = {
                whitePieces: ['rook', 'knight', 'bishop', 'king', 'queen', 'bishop', 'knight', 'rook',
                             'pawn', 'pawn', 'pawn', 'pawn', 'pawn', 'pawn', 'pawn', 'pawn'],
                whiteLocations: [[0,0], [1,0], [2,0], [3,0], [4,0], [5,0], [6,0], [7,0],
                               [0,1], [1,1], [2,1], [3,1], [4,1], [5,1], [6,1], [7,1]],
                blackPieces: ['rook', 'knight', 'bishop', 'king', 'queen', 'bishop', 'knight', 'rook',
                             'pawn', 'pawn', 'pawn', 'pawn', 'pawn', 'pawn', 'pawn', 'pawn'],
                blackLocations: [[0,7], [1,7], [2,7], [3,7], [4,7], [5,7], [6,7], [7,7],
                               [0,6], [1,6], [2,6], [3,6], [4,6], [5,6], [6,6], [7,6]],
                whiteMoved: new Array(16).fill(false),
                blackMoved: new Array(16).fill(false),
                capturedPiecesWhite: [],
                capturedPiecesBlack: [],
                turnStep: 0,
                gameOver: false,
                winner: '',
                whiteEp: [100, 100],
                blackEp: [100, 100],
                inCheck: false,
                checkedKing: null
            };
            checkFlashCounter = 0;
            updateCapturedPieces();
        }
        
        function updateStatus(message) {
            const statusEl = document.getElementById('statusMessage');
            const turnIndicator = document.getElementById('turnIndicator');
            
            if (gameState.gameOver) {
                turnIndicator.textContent = gameState.winner.toUpperCase();
                turnIndicator.className = 'turn-indicator ' + (gameState.winner === 'white' ? 'white-turn' : 'black-turn');
                statusEl.textContent = 'Won the game!';
            } else {
                const isWhiteTurn = gameState.turnStep < 2;
                turnIndicator.textContent = isWhiteTurn ? 'WHITE' : 'BLACK';
                turnIndicator.className = 'turn-indicator ' + (isWhiteTurn ? 'white-turn' : 'black-turn');
                
                if (message) {
                    statusEl.textContent = message;
                } else {
                    const statusTexts = ['Select a Piece to Move!', 'Select a Destination!',
                                       'Select a Piece to Move!', 'Select a Destination!'];
                    statusEl.textContent = statusTexts[gameState.turnStep] || 'Game in progress';
                }
            }
        }
        
        // Socket event handlers
        socket.on('connect', () => {
            console.log('Connected to server');
        });
        
        socket.on('room_created', (data) => {
            roomCode = data.room_code;
            playerColor = data.color;
            currentMode = 'online';
            document.getElementById('roomCodeText').textContent = roomCode;
            document.getElementById('roomCodeDisplay').style.display = 'block';
            document.getElementById('menuScreen').classList.add('hidden');
            document.getElementById('gameScreen').classList.remove('hidden');
            initializeGameState();
            initBoard();
            updateBoardDisplay();
            document.getElementById('statusMessage').textContent = 'Waiting for opponent...';
        });
        
        socket.on('joined_room', (data) => {
            roomCode = data.room_code;
            playerColor = data.color;
            currentMode = 'online';
            document.getElementById('roomCodeText').textContent = roomCode;
            document.getElementById('roomCodeDisplay').style.display = 'block';
            document.getElementById('menuScreen').classList.add('hidden');
            document.getElementById('gameScreen').classList.remove('hidden');
            initializeGameState();
            initBoard();
            updateBoardDisplay();
            if (data.status === 'ready') {
                document.getElementById('statusMessage').textContent = 'Game starting!';
            } else {
                document.getElementById('statusMessage').textContent = 'Waiting for opponent...';
            }
        });
        
        socket.on('game_start', () => {
            initializeGameState();
            updateBoardDisplay();
            updateStatus();
        });
        
        socket.on('opponent_move', (data) => {
            if (data.game_state) {
                const gs = data.game_state;
                gameState.whitePieces = gs.whitePieces || gs.white_pieces || gameState.whitePieces;
                gameState.whiteLocations = (gs.whiteLocations || gs.white_locations || gameState.whiteLocations).map(loc => Array.isArray(loc) ? loc : [loc[0], loc[1]]);
                gameState.blackPieces = gs.blackPieces || gs.black_pieces || gameState.blackPieces;
                gameState.blackLocations = (gs.blackLocations || gs.black_locations || gameState.blackLocations).map(loc => Array.isArray(loc) ? loc : [loc[0], loc[1]]);
                gameState.capturedPiecesWhite = gs.capturedPiecesWhite || gs.captured_pieces_white || gameState.capturedPiecesWhite;
                gameState.capturedPiecesBlack = gs.capturedPiecesBlack || gs.captured_pieces_black || gameState.capturedPiecesBlack;
                gameState.turnStep = gs.turnStep !== undefined ? gs.turnStep : (gs.turn_step !== undefined ? gs.turn_step : gameState.turnStep);
                gameState.gameOver = gs.gameOver !== undefined ? gs.gameOver : (gs.game_over !== undefined ? gs.game_over : gameState.gameOver);
                gameState.winner = gs.winner || gameState.winner;
                gameState.whiteEp = gs.whiteEp || gs.white_ep || gameState.whiteEp || [100, 100];
                gameState.blackEp = gs.blackEp || gs.black_ep || gameState.blackEp || [100, 100];
                gameState.whiteMoved = gs.whiteMoved || gs.white_moved || gameState.whiteMoved;
                gameState.blackMoved = gs.blackMoved || gs.black_moved || gameState.blackMoved;
                ensureMovedArrays();
                updateBoardDisplay();
                updateCapturedPieces();
            } else if (data.from_pos && data.to_pos) {
                updateLocalMove(data.from_pos, data.to_pos, data.is_en_passant || false);
            }
            updateStatus();
        });
        
        socket.on('game_state_update', (data) => {
            if (data.game_state) {
                const gs = data.game_state;
                gameState.whitePieces = gs.whitePieces || gs.white_pieces || gameState.whitePieces;
                gameState.whiteLocations = (gs.whiteLocations || gs.white_locations || gameState.whiteLocations).map(loc => Array.isArray(loc) ? loc : [loc[0], loc[1]]);
                gameState.blackPieces = gs.blackPieces || gs.black_pieces || gameState.blackPieces;
                gameState.blackLocations = (gs.blackLocations || gs.black_locations || gameState.blackLocations).map(loc => Array.isArray(loc) ? loc : [loc[0], loc[1]]);
                gameState.capturedPiecesWhite = gs.capturedPiecesWhite || gs.captured_pieces_white || gameState.capturedPiecesWhite;
                gameState.capturedPiecesBlack = gs.capturedPiecesBlack || gs.captured_pieces_black || gameState.capturedPiecesBlack;
                gameState.turnStep = gs.turnStep !== undefined ? gs.turnStep : (gs.turn_step !== undefined ? gs.turn_step : gameState.turnStep);
                gameState.gameOver = gs.gameOver !== undefined ? gs.gameOver : (gs.game_over !== undefined ? gs.game_over : gameState.gameOver);
                gameState.winner = gs.winner || gameState.winner;
                gameState.whiteEp = gs.whiteEp || gs.white_ep || gameState.whiteEp || [100, 100];
                gameState.blackEp = gs.blackEp || gs.black_ep || gameState.blackEp || [100, 100];
                gameState.whiteMoved = gs.whiteMoved || gs.white_moved || gameState.whiteMoved;
                gameState.blackMoved = gs.blackMoved || gs.black_moved || gameState.blackMoved;
                ensureMovedArrays();
                updateBoardDisplay();
                updateCapturedPieces();
            }
        });
        
        socket.on('opponent_forfeited', (data) => {
            gameState.winner = data.winner;
            gameState.gameOver = true;
            updateBoardDisplay();
            updateStatus();
            alert(`${data.winner.toUpperCase()} won! ${data.message || 'Opponent forfeited.'}`);
        });
        
        socket.on('forfeit_confirmed', (data) => {
            gameState.winner = data.winner;
            gameState.gameOver = true;
            updateBoardDisplay();
            updateStatus();
            alert(`You forfeited. ${data.winner.toUpperCase()} wins!`);
        });
        
        socket.on('pawn_promoted', (data) => {
            if (data.game_state) {
                const gs = data.game_state;
                gameState.whitePieces = gs.whitePieces || gs.white_pieces || gameState.whitePieces;
                gameState.blackPieces = gs.blackPieces || gs.black_pieces || gameState.blackPieces;
                gameState.whiteLocations = (gs.whiteLocations || gs.white_locations || gameState.whiteLocations).map(loc => Array.isArray(loc) ? loc : [loc[0], loc[1]]);
                gameState.blackLocations = (gs.blackLocations || gs.black_locations || gameState.blackLocations).map(loc => Array.isArray(loc) ? loc : [loc[0], loc[1]]);
                gameState.whiteMoved = gs.whiteMoved || gs.white_moved || gameState.whiteMoved;
                gameState.blackMoved = gs.blackMoved || gs.black_moved || gameState.blackMoved;
                ensureMovedArrays();
                updateBoardDisplay();
            }
        });
        
        // Keyboard event handlers
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape' || event.key === 'Esc') {
                const gameScreen = document.getElementById('gameScreen');
                if (!gameScreen.classList.contains('hidden')) {
                    goBackToMenu();
                }
            }
        });
    </script>
</body>
</html>
